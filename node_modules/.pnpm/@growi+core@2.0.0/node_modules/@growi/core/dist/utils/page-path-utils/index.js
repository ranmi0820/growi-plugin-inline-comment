import n from "escape-string-regexp";
import { isValidObjectId as c } from "../objectid-utils.js";
import { addTrailingSlash as o } from "../path-utils.js";
import { isTopPage as u } from "./is-top-page.js";
import { generateChildrenRegExp as k } from "./generate-children-regexp.js";
const l = u, h = (e) => e === "/user", x = (e) => {
  const t = e.substring(1);
  return c(t);
}, p = (e) => !!e.match(/^\/user\/[^/]+$/), g = (e) => h(e) || p(e), A = (e) => !l(e) && !g(e), R = (e) => !!e.match(/^\/user\/.*?$/), S = (e) => e === "/trash", T = (e) => !!e.match(/^\/trash(\/.*)?$/), v = (e) => !!e.match(/^\/share(\/.*)?$/), m = [
  /\^|\$|\*|\+|#|<|>|%|\?/,
  /^\/-\/.*/,
  /^\/_r\/.*/,
  /^\/_apix?(\/.*)?/,
  /^\/?https?:\/\/.+$/,
  // avoid miss in renaming
  /\/{2,}/,
  // avoid miss in renaming
  /\s+\/\s+/,
  // avoid miss in renaming
  /.+\/edit$/,
  /.+\.md$/,
  /^(\.\.)$/,
  // see: https://github.com/growilabs/growi/issues/3582
  /(\/\.\.)\/?/,
  // see: https://github.com/growilabs/growi/issues/3582
  /\\/,
  // see: https://github.com/growilabs/growi/issues/7241
  /^\/(_search|_private-legacy-pages)(\/.*|$)/,
  /^\/(installer|register|login|logout|admin|me|files|trash|paste|comments|tags|share|attachment)(\/.*|$)/,
  /^\/user(?:\/[^/]+)?$/,
  // https://regex101.com/r/9Eh2S1/1
  /^(\/.+){130,}$/
  // avoid deep layer path. see: https://regex101.com/r/L0kzOD/1
], f = (e) => !m.some((t) => e.match(t)), b = (e) => (e == null ? void 0 : e.username) == null ? "" : `/user/${e.username}`, y = (e, t, r) => {
  if (t == null)
    throw new Error("Please input the new page path");
  const s = new RegExp(`^${n(e)}`, "i");
  return r.replace(s, t);
}, D = (e) => {
  if (e != null)
    return e.replace(/ /g, "%20").replace(/\u3000/g, "%E3%80%80");
}, U = (...e) => {
  const t = [...e].join("/");
  if (!f(t))
    throw new Error("Invalid characters on path");
  try {
    return `${new URL(t, "https://dummy").pathname}#edit`;
  } catch {
    throw new Error("Invalid path format");
  }
}, I = (e) => {
  const t = Array.from(new Set(e));
  return t.filter((r) => !(t.filter((a) => new RegExp(`^${a}\\/.+`, "i").test(r)).length > 0));
}, O = (e) => e.filter((t) => !e.some(
  (s) => new RegExp(`^${s.path}\\/.+`, "i").test(t.path)
)), _ = (e, t) => {
  if (e === t)
    return !0;
  const r = o(e), s = o(t), a = new RegExp(`^${n(r)}`, "i"), i = new RegExp(`^${n(s)}`, "i");
  return !!(a.test(t) || i.test(e));
}, P = (e, t) => {
  if (e === t)
    return !0;
  const r = o(e);
  return !!new RegExp(
    `^${n(r)}`,
    "i"
  ).test(t);
}, j = (e, t) => !P(e, t), C = (e) => e.includes("/"), W = (e) => {
  let t = null;
  const r = e.match(/^\/user\/([^/]+)\/?/);
  return r && (t = r[1]), t;
}, F = (e) => /^(?:\/[^/*?[\]{}]+)*\/\*$/.test(e);
export {
  j as canMoveByPath,
  y as convertToNewAffiliationPath,
  D as encodeSpaces,
  k as generateChildrenRegExp,
  U as generateEditorPath,
  W as getUsernameByPath,
  C as hasSlash,
  f as isCreatablePage,
  _ as isEitherOfPathAreaOverlap,
  F as isGlobPatternPath,
  A as isMovablePage,
  P as isPathAreaOverlap,
  x as isPermalink,
  v as isSharedPage,
  l as isTopPage,
  T as isTrashPage,
  S as isTrashTopPage,
  R as isUserPage,
  p as isUsersHomepage,
  g as isUsersProtectedPages,
  h as isUsersTopPage,
  O as omitDuplicateAreaPageFromPages,
  I as omitDuplicateAreaPathFromPaths,
  b as userHomepagePath
};
//# sourceMappingURL=index.js.map
